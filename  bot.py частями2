import asyncio
import logging
import os
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import feedparser
from aiogram import Bot, Dispatcher, F, Router
from aiogram.enums import ParseMode
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.utils.markdown import hbold
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from openai import OpenAI
from dotenv import load_dotenv

# ---------- НАСТРОЙКА ОКРУЖЕНИЯ И ЛОГГЕРОВ ----------
load_dotenv()
API_TOKEN = os.getenv("API_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ---------- ИНИЦИАЛИЗАЦИЯ ----------
bot = Bot(token=API_TOKEN, default_parse_mode=ParseMode.HTML)
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)
scheduler = AsyncIOScheduler()
client = OpenAI(api_key=OPENAI_API_KEY)

DB_FILE = "users.db"
DEFAULT_PROMPT = (
    "Ты аналитик криптовалютного проекта A7A5. "
    "Оцени релевантность новости по теме: криптовалюта, стейблкоины, цифровой рубль, экономика Кыргызстана. "
    "Ответь одним словом — да или нет."
)

# ---------- СОЗДАНИЕ ТАБЛИЦЫ И ИСТОЧНИКИ ----------
def init_db():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY)")
    cur.execute("CREATE TABLE IF NOT EXISTS sent_links (link TEXT PRIMARY KEY)")
    cur.execute("CREATE TABLE IF NOT EXISTS sources (url TEXT PRIMARY KEY)")
    conn.commit()

    sources = [
        "https://forklog.com/feed/",
        "https://ru.cointelegraph.com/rss",
        "https://bits.media/rss/news/",
        "https://incrypted.com/feed/",
        "https://cryptopanic.com/news/rss/",
        "https://cointelegraph.com/rss",
        "https://decrypt.co/feed",
        "https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml",
        "https://www.cbr.ru/rss/",
        "http://www.finmarket.ru/rss/",
        "https://rssexport.rbc.ru/rbcnews/news/eco/index.rss",
        "https://www.kommersant.ru/RSS/news.xml",
        "https://www.forbes.ru/rss",
        "https://24.kg/rss/",
        "https://akipress.org/rss/news.rss",
        "https://www.themoscowtimes.com/rss",
        "https://blogs.imf.org/feed/",
        "https://www.bis.org/rss/home.xml",
    ]
    for url in sources:
        cur.execute("INSERT OR IGNORE INTO sources (url) VALUES (?)", (url,))
    conn.commit()
    conn.close()
    
# ---------- ПОЛЬЗОВАТЕЛЬСКИЕ ПРОМТЫ ----------
user_prompts: Dict[int, str] = {}

# ---------- КОМАНДА /start ----------
@router.message(F.text == "/start")
async def cmd_start(message: Message):
    user_id = message.from_user.id
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO users (id) VALUES (?)", (user_id,))
    conn.commit()
    conn.close()

    kb = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="Справка", callback_data="help")],
        ]
    )
    await message.answer(f"{hbold('Привет!')} Я присылаю свежие релевантные новости по теме A7A5, криптовалют, цифрового рубля и экономики. Нажми «Справка», чтобы узнать команды.", reply_markup=kb)

# ---------- КОМАНДА /help ----------
@router.message(F.text == "/help")
@router.callback_query(F.data == "help")
async def help_msg(event: Message):
    await event.answer(
        "/digest — получить свежие новости\n"
        "/setprompt — ввести пользовательский промт\n"
        "/listsources — список источников\n"
        "/addsource <url> — добавить источник\n"
        "/removesource <url> — удалить источник"
    )

# ---------- КОМАНДА /setprompt ----------
@router.message(F.text.startswith("/setprompt"))
async def set_prompt(message: Message):
    prompt_text = message.text.replace("/setprompt", "").strip()
    if not prompt_text:
        await message.answer("Пожалуйста, отправьте промт сразу после команды: /setprompt ТЕКСТ")
    else:
        user_prompts[message.from_user.id] = prompt_text
        await message.answer("Промт обновлён! Теперь поиск будет по вашему запросу.")

# ---------- КОМАНДА /digest ----------
@router.message(F.text == "/digest")
async def digest_cmd(message: Message):
    await message.answer("Собираю новости, подождите...")
    articles, stats = await get_news(message.from_user.id)

    if not articles:
        await message.answer("Нет релевантных новостей.")
        return

    result = "Результаты:\n\n"
    total_r = total_i = total_p = 0
    for src, data in stats.items():
        result += f"{src}\n  Прочитано: {data['total']}, Релевантно: {data['relevant']}, Возможно: {data['possible']}, Нерелевантно: {data['irrelevant']}\n"
        total_r += data['relevant']
        total_p += data['possible']
        total_i += data['irrelevant']

    result += f"\nВсего новостей: {total_r + total_p + total_i}\n"
    result += f"{total_r} релевантных, {total_p} возможно, {total_i} нерелевантных."
    await message.answer(result)

    for art in articles:
        if art['status'] == "Relevant":
            await message.answer(f"<b>{art['title']}</b>\n{art['link']}")
            
# ---------- GPT АНАЛИЗ ----------
async def gpt_check(prompt: str) -> str:
    try:
        loop = asyncio.get_running_loop()
        response = await loop.run_in_executor(
            None,
            lambda: client.chat.completions.create(
                model="gpt-3.5-turbo",  # или gpt-4 если доступен
                messages=[{"role": "user", "content": prompt}],
                max_tokens=5,
                temperature=0,
            )
        )
        return response.choices[0].message.content.strip().lower()
    except Exception as e:
        logging.error(f"OpenAI API error: {e}", exc_info=True)
        return "нет"

# ---------- ПАРСИНГ НОВОСТЕЙ ----------
async def get_news(user_id: int):
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT url FROM sources")
    sources = [r[0] for r in cur.fetchall()]
    new_articles = []
    stats = {}

    prompt = user_prompts.get(user_id) or (
        "Ты аналитик криптопроекта A7A5. Ответь, релевантна ли новость, если она касается цифрового рубля, крипты, экономики Кыргызстана, CBDC и т.п. Ответь одним словом: да или нет."
    )

    for url in sources:
        stats[url] = {"total": 0, "relevant": 0, "irrelevant": 0, "possible": 0}
        try:
            feed = feedparser.parse(url)
            for entry in feed.entries:
                title = entry.get("title", "")
                link = entry.get("link", "")
                summary = entry.get("summary", "")
                content = entry.get("content", [{}])[0].get("value", "")
                published = entry.get("published_parsed")

                # Игнорируем старые новости только если есть дата
                if published:
                    pub_dt = datetime(*published[:6])
                    if datetime.utcnow() - pub_dt > timedelta(days=7):
                        continue

                cur.execute("SELECT 1 FROM sent_links WHERE link = ?", (link,))
                if cur.fetchone():
                    continue

                full_text = f"Заголовок: {title}\nОписание: {summary}\nКонтент: {content[:500]}"
                relevance = await gpt_check(f"{prompt}\n\n{full_text}")
                status = "Irrelevant"
                if "да" in relevance:
                    status = "Relevant"
                elif "возможно" in relevance or "может быть" in relevance:
                    status = "Possible"

                stats[url]["total"] += 1
                stats[url][status.lower()] += 1
                cur.execute("INSERT INTO sent_links (link) VALUES (?)", (link,))
                new_articles.append({"title": title, "link": link, "status": status, "source": url})
        except Exception as e:
            logging.warning(f"Ошибка при парсинге {url}: {e}")

    conn.commit()
    conn.close()
    return new_articles, stats

# ---------- УПРАВЛЕНИЕ ИСТОЧНИКАМИ ----------
@router.message(F.text == "/listsources")
async def list_sources(message: Message):
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT url FROM sources")
    rows = cur.fetchall()
    conn.close()
    if rows:
        text = "\n".join(url for (url,) in rows)
        await message.answer("Текущие источники:\n" + text)
    else:
        await message.answer("Список источников пуст.")

@router.message(F.text.startswith("/addsource"))
async def add_source(message: Message):
    url = message.text.replace("/addsource", "").strip()
    if not url.startswith("http"):
        await message.answer("Некорректная ссылка.")
        return
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO sources (url) VALUES (?)", (url,))
    conn.commit()
    conn.close()
    await message.answer("Источник добавлен.")

@router.message(F.text.startswith("/removesource"))
async def remove_source(message: Message):
    url = message.text.replace("/removesource", "").strip()
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("DELETE FROM sources WHERE url = ?", (url,))
    conn.commit()
    conn.close()
    await message.answer("Источник удалён.")

# ---------- ПЛАНИРОВЩИК ----------
async def scheduled_job():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT id FROM users")
    users = [row[0] for row in cur.fetchall()]
    conn.close()

    for user_id in users:
        try:
            articles, _ = await get_news(user_id)
            for article in articles:
                if article['status'] == 'Relevant':
                    await bot.send_message(user_id, f"<b>{article['title']}</b>\n{article['link']}")
        except Exception as e:
            logging.error(f"Ошибка рассылки пользователю {user_id}: {e}")
# ---------- ON_STARTUP: инициализация базы, удаление вебхука, запуск планировщика ----------
async def on_startup(bot: Bot):
    init_db()
    await bot.delete_webhook(drop_pending_updates=True)
    scheduler.add_job(scheduled_job, "cron", hour=11, minute=0)
    scheduler.start()
    logging.info("Бот успешно запущен.")

# ---------- ON_SHUTDOWN ----------
async def on_shutdown(bot: Bot):
    logging.info("Бот остановлен.")
    scheduler.shutdown()

# ---------- ЗАПУСК ----------
async def main():
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s"
    )

    dp.include_router(router)
    await dp.start_polling(bot, on_startup=on_startup, on_shutdown=on_shutdown)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())