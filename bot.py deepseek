import asyncio
import logging
import os
import feedparser
from datetime import datetime, timedelta
from typing import List, Dict, Tuple

from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import StatesGroup, State
from aiogram import Router
from aiogram.filters import Command, CommandStart
from openai import OpenAI

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
load_dotenv()
API_TOKEN = os.getenv("API_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.FileHandler("bot.log"), logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = Bot(token=API_TOKEN, parse_mode=ParseMode.HTML)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

# –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
RUSSIAN_KEYWORDS = [
    "–∫—Ä–∏–ø—Ç–∞", "–±–∏—Ç–∫–æ–∏–Ω", "—ç—Ñ–∏—Ä–∏—É–º", "—Å—Ç–µ–π–±–ª–∫–æ–∏–Ω", "—Ä—É–±–ª—å", "–±–ª–æ–∫—á–µ–π–Ω",
    "—Ü–∏—Ñ—Ä–æ–≤–æ–π", "CBDC", "—Ä–µ–≥—É–ª—è—Ç–æ—Ä", "–º–∞–π–Ω–∏–Ω–≥", "–∫–æ—à–µ–ª–µ–∫", "—Ç–æ–∫–µ–Ω",
    "–¥–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–∞—Ü–∏—è", "—Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç", "–±–∏—Ä–∂–∞", "–ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å"
]

ENGLISH_KEYWORDS = [
    "crypto", "bitcoin", "ethereum", "stablecoin", "ruble", "blockchain",
    "digital", "CBDC", "regulation", "mining", "wallet", "token",
    "decentralization", "smart contract", "exchange", "liquidity"
]

# –ú–µ—Ç–æ–¥—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
FILTER_METHODS = {
    "keywords": "–¢–æ–ª—å–∫–æ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞",
    "gpt": "GPT-3.5 Turbo",
    "openrouter": "OpenRouter",
    "multistage": "–ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è"
}
user_filters = {}

# –°–æ—Å—Ç–æ—è–Ω–∏—è
class UserStates(StatesGroup):
    waiting_prompt = State()
    waiting_filter = State()

# –ë–∞–∑–∞ –Ω–æ–≤–æ—Å—Ç–µ–π
sent_links = set()
user_prompts = {}

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ (NEWS_SOURCES –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –∏–∑ –≤–∞—à–µ–≥–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∫–æ–¥–∞)

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
async def check_keywords(text: str) -> Tuple[bool, List[str]]:
    text_lower = text.lower()
    found_keywords = []
    
    for word in RUSSIAN_KEYWORDS + ENGLISH_KEYWORDS:
        if word.lower() in text_lower:
            found_keywords.append(word)
    
    return len(found_keywords) > 0, found_keywords

async def ai_check(text: str, prompt: str, method: str) -> Tuple[bool, str]:
    try:
        client = OpenAI(
            api_key=OPENAI_API_KEY if method == "gpt" else OPENROUTER_API_KEY,
            base_url="https://openrouter.ai/api/v1" if method == "openrouter" else None
        )
        
        messages = [
            {"role": "system", "content": "–û–ø—Ä–µ–¥–µ–ª–∏ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å –Ω–æ–≤–æ—Å—Ç–∏. –û—Ç–≤–µ—Ç—å –¢–û–õ–¨–ö–û '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç'."},
            {"role": "user", "content": f"{prompt}\n\n–ù–æ–≤–æ—Å—Ç—å:\n{text}"}
        ]
        
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo" if method == "gpt" else "mistralai/mixtral-8x7b",
            messages=messages,
            temperature=0.3
        )
        
        decision = response.choices[0].message.content.lower()
        return "–¥–∞" in decision, decision
    
    except Exception as e:
        logger.error(f"AI Error ({method}): {str(e)}")
        return False, "error"

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
@router.message(CommandStart())
async def start(message: Message):
    builder = InlineKeyboardBuilder()
    builder.button(text="–í—ã–±—Ä–∞—Ç—å —Ñ–∏–ª—å—Ç—Ä", callback_data="set_filter")
    await message.answer(
        f"üëã –ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}! –Ø –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–π –±–æ—Ç A7A5.\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π /filter –¥–ª—è –≤—ã–±–æ—Ä–∞ –º–µ—Ç–æ–¥–∞ –∞–Ω–∞–ª–∏–∑–∞.",
        reply_markup=builder.as_markup()
    )

@router.message(Command("filter"))
async def filter_command(message: Message):
    builder = InlineKeyboardBuilder()
    for key, name in FILTER_METHODS.items():
        builder.button(text=name, callback_data=f"filter_{key}")
    builder.adjust(1)
    await message.answer("üîç –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏:", reply_markup=builder.as_markup())

@router.callback_query(F.data.startswith("filter_"))
async def set_filter(callback: CallbackQuery):
    method = callback.data.split("_")[1]
    user_filters[callback.from_user.id] = method
    await callback.message.edit_text(f"‚úÖ –í—ã–±—Ä–∞–Ω –º–µ—Ç–æ–¥: {FILTER_METHODS[method]}")

@router.message(Command("digest"))
async def digest(message: Message, state: FSMContext):
    user_id = message.from_user.id
    method = user_filters.get(user_id, "multistage")
    
    await message.answer("üîé –ù–∞—á–∏–Ω–∞—é –∞–Ω–∞–ª–∏–∑ –Ω–æ–≤–æ—Å—Ç–µ–π...")
    results = []
    stats = {"passed": 0, "filtered": 0, "errors": 0}

    for url in NEWS_SOURCES:
        try:
            feed = feedparser.parse(url)
            for entry in feed.entries[:50]:
                if entry.link in sent_links:
                    continue
                
                content = f"{entry.title}\n{entry.get('summary', '')}"
                keyword_check, found_words = await check_keywords(content)
                
                if keyword_check:
                    results.append(entry.link)
                    sent_links.add(entry.link)
                    stats["passed"] += 1
                    logger.info(f"Keywords matched: {', '.join(found_words)} | URL: {entry.link}")
                    continue
                
                if method == "keywords":
                    stats["filtered"] += 1
                    logger.info(f"Filtered (keywords): {entry.link}")
                    continue
                
                ai_result, reason = await ai_check(
                    content,
                    user_prompts.get(user_id, "–†–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ –ª–∏ —ç—Ç–æ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞–º –∏ —Ü–∏—Ñ—Ä–æ–≤–æ–π —ç–∫–æ–Ω–æ–º–∏–∫–µ?"),
                    method if method in ["gpt", "openrouter"] else "gpt"
                )
                
                if ai_result:
                    results.append(entry.link)
                    sent_links.add(entry.link)
                    stats["passed"] += 1
                else:
                    stats["filtered"] += 1
                    logger.info(f"Filtered ({method}): {reason} | URL: {entry.link}")
                    
        except Exception as e:
            stats["errors"] += 1
            logger.error(f"Error processing {url}: {str(e)}")

    response = (
        f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã:\n"
        f"‚Ä¢ –ù–∞–π–¥–µ–Ω–æ: {stats['passed']}\n"
        f"‚Ä¢ –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ: {stats['filtered']}\n"
        f"‚Ä¢ –û—à–∏–±–æ–∫: {stats['errors']}\n\n"
    )
    
    if results:
        response += "üîó –°—Å—ã–ª–∫–∏:\n" + "\n".join(results[:15])
    else:
        response += "‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã."
    
    await message.answer(response)

@router.message(Command("status"))
async def status(message: Message):
    user_id = message.from_user.id
    method = FILTER_METHODS.get(user_filters.get(user_id, "multistage"))
    
    status_msg = (
        f"‚öôÔ∏è –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å:\n"
        f"‚Ä¢ –ú–µ—Ç–æ–¥ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: {method}\n"
        f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∫–ª—é—á–µ–π: {len(RUSSIAN_KEYWORDS + ENGLISH_KEYWORDS)}\n"
        f"‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Å—Å—ã–ª–æ–∫: {len(sent_links)}\n"
        f"‚Ä¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –ø—Ä–æ–º–ø—Ç–æ–≤: {len(user_prompts)}"
    )
    await message.answer(status_msg)

# –ó–∞–ø—É—Å–∫
async def main():
    await bot.delete_webhook()
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())