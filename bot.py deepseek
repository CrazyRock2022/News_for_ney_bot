import asyncio
import logging
import os
import feedparser
from datetime import datetime, timedelta
from typing import List, Dict, Tuple

from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import StatesGroup, State
from aiogram import Router
from aiogram.filters import Command, CommandStart
from openai import OpenAI
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()
API_TOKEN = os.getenv("API_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.FileHandler("bot.log"), logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
from aiogram.client.default import DefaultBotProperties

bot = Bot(
    token=API_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

# –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
RUSSIAN_KEYWORDS = [
    "–∫—Ä–∏–ø—Ç–∞", "–±–∏—Ç–∫–æ–∏–Ω", "—ç—Ñ–∏—Ä–∏—É–º", "—Å—Ç–µ–π–±–ª–∫–æ–∏–Ω", "—Ä—É–±–ª—å", "–±–ª–æ–∫—á–µ–π–Ω",
    "—Ü–∏—Ñ—Ä–æ–≤–æ–π", "CBDC", "—Ä–µ–≥—É–ª—è—Ç–æ—Ä", "–º–∞–π–Ω–∏–Ω–≥", "–∫–æ—à–µ–ª–µ–∫", "—Ç–æ–∫–µ–Ω",
    "–¥–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–∞—Ü–∏—è", "—Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç", "–±–∏—Ä–∂–∞", "–ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å"
]

ENGLISH_KEYWORDS = [
    "crypto", "bitcoin", "ethereum", "stablecoin", "ruble", "blockchain",
    "digital", "CBDC", "regulation", "mining", "wallet", "token",
    "decentralization", "smart contract", "exchange", "liquidity"
]

# –ú–µ—Ç–æ–¥—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
FILTER_METHODS = {
    "keywords": "–¢–æ–ª—å–∫–æ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞",
    "openrouter": "OpenRouter",
    "gpt": "GPT-3.5 Turbo",
    "multistage": "–ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è"
}
user_filters = {}

# –°–æ—Å—Ç–æ—è–Ω–∏—è
class UserStates(StatesGroup):
    waiting_prompt = State()
    waiting_filter = State()

# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
sent_links_cache = set()
user_prompts = {}

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ –Ω–æ–≤–æ—Å—Ç–µ–π
NEWS_SOURCES = [
    "https://forklog.com/feed/",
    "https://ru.cointelegraph.com/rss",
    "https://bits.media/rss/news/",
    "https://incrypted.com/feed/",
    "https://cryptopanic.com/news/rss/",
    "https://cointelegraph.com/rss",
    "https://decrypt.co/feed",
    "https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml",
    "https://www.cbr.ru/rss/",
    "http://www.finmarket.ru/rss/",
    "https://rssexport.rbc.ru/rbcnews/news/eco/index.rss",
    "https://www.kommersant.ru/RSS/news.xml",
    "https://www.forbes.ru/rss",
    "https://24.kg/rss/",
    "https://akipress.org/rss/news.rss",
    "https://www.themoscowtimes.com/rss",
    "https://blogs.imf.org/feed/",
    "https://www.bis.org/rss/home.xml"
]

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ç–µ–∂: (bool, list))
async def check_keywords(text: str) -> Tuple[bool, List[str]]:
    text_lower = text.lower()
    found_keywords = []
    
    for word in RUSSIAN_KEYWORDS + ENGLISH_KEYWORDS:
        if word.lower() in text_lower:
            found_keywords.append(word)
    
    return (len(found_keywords) > 0, found_keywords)

# AI-—Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
async def ai_check(text: str, prompt: str, method: str) -> Tuple[bool, str]:
    try:
        client = OpenAI(
            api_key=OPENAI_API_KEY if method == "gpt" else OPENROUTER_API_KEY,
            base_url="https://openrouter.ai/api/v1" if method == "openrouter" else None
        )
        
        messages = [
            {"role": "system", "content": "–û—Ç–≤–µ—Ç—å —Ç–æ–ª—å–∫–æ '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç'. –†–µ–ª–µ–≤–∞–Ω—Ç–Ω–∞ –ª–∏ –Ω–æ–≤–æ—Å—Ç—å —Ç–µ–º–µ?"},
            {"role": "user", "content": f"{prompt}\n\n{text}"}
        ]
        
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo" if method == "gpt" else "mistralai/mixtral-8x7b",
            messages=messages,
            temperature=0.3
        )
        
        decision = response.choices[0].message.content.lower()
        return ("–¥–∞" in decision, decision)
    
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ {method}: {str(e)}")
        return (False, "error")

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
async def multi_filter(text: str, prompt: str, user_id: int) -> str:
    # –í—Å–µ–≥–¥–∞ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
    keywords_found, found_words = await check_keywords(text)
    if keywords_found:
        logger.info(f"–ù–∞–π–¥–µ–Ω—ã –∫–ª—é—á–∏: {', '.join(found_words)}")
        return "relevant"
    
    method = user_filters.get(user_id, "multistage")
    
    # –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
    if method == "multistage":
        # OpenRouter
        openrouter_result, _ = await ai_check(text, prompt, "openrouter")
        if openrouter_result:
            return "relevant"
        
        # GPT
        gpt_result, _ = await ai_check(text, prompt, "gpt")
        if gpt_result:
            return "relevant"
        
        return "irrelevant"
    
    # –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    if method == "openrouter":
        result, _ = await ai_check(text, prompt, "openrouter")
        return "relevant" if result else "irrelevant"
    
    if method == "gpt":
        result, _ = await ai_check(text, prompt, "gpt")
        return "relevant" if result else "irrelevant"
    
    return "irrelevant"

# –ö–æ–º–∞–Ω–¥—ã
@router.message(CommandStart())
async def cmd_start(message: Message):
    await message.answer(
        f"–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}! –Ø –±–æ—Ç A7A5.\n\n"
        "–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –Ω–æ–≤–æ—Å—Ç–∏ –ø–æ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞–º –∏ —ç–∫–æ–Ω–æ–º–∏–∫–µ. –ò—Å–ø–æ–ª—å–∑—É–π /digest –¥–ª—è –∑–∞–ø—É—Å–∫–∞."
    )

@router.message(Command("filter"))
async def cmd_filter(message: Message):
    builder = InlineKeyboardBuilder()
    for key, name in FILTER_METHODS.items():
        builder.button(text=name, callback_data=f"filter_{key}")
    builder.adjust(1)
    await message.answer("üîç –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏:", reply_markup=builder.as_markup())

@router.callback_query(F.data.startswith("filter_"))
async def set_filter(callback: CallbackQuery):
    method = callback.data.split("_")[1]
    user_filters[callback.from_user.id] = method
    await callback.message.edit_text(f"‚úÖ –í—ã–±—Ä–∞–Ω –º–µ—Ç–æ–¥: {FILTER_METHODS[method]}")

@router.message(Command("digest"))
async def cmd_digest(message: Message):
    user_id = message.from_user.id
    await message.answer("üîé –ù–∞—á–∏–Ω–∞—é –∞–Ω–∞–ª–∏–∑...")
    
    results = []
    stats = {"total": 0, "passed": 0, "filtered": 0, "errors": 0}
    
    for url in NEWS_SOURCES:
        try:
            feed = feedparser.parse(url)
            for entry in feed.entries[:50]:
                stats["total"] += 1
                if entry.link in sent_links_cache:
                    continue
                
                content = f"{entry.title}\n{entry.get('summary', '')}"
                verdict = await multi_filter(content, "", user_id)
                
                if verdict == "relevant":
                    results.append(entry.link)
                    sent_links_cache.add(entry.link)
                    stats["passed"] += 1
                else:
                    stats["filtered"] += 1
                    logger.info(f"–û—Ç–±—Ä–∞–∫–æ–≤–∞–Ω–æ: {entry.link}")
                    
        except Exception as e:
            stats["errors"] += 1
            logger.error(f"–û—à–∏–±–∫–∞ {url}: {str(e)}")
    
    response = (
        f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã:\n"
        f"‚Ä¢ –í—Å–µ–≥–æ: {stats['total']}\n"
        f"‚Ä¢ –ü–æ–¥—Ö–æ–¥—è—â–∏—Ö: {stats['passed']}\n"
        f"‚Ä¢ –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ: {stats['filtered']}\n"
        f"‚Ä¢ –û—à–∏–±–æ–∫: {stats['errors']}\n\n"
    )
    
    if results:
        response += "üîó –°—Å—ã–ª–∫–∏:\n" + "\n".join(results[:15])
    else:
        response += "‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∏–ª—å—Ç—Ä."
    
    await message.answer(response)

@router.message(Command("status"))
async def cmd_status(message: Message):
    uid = message.from_user.id
    method = FILTER_METHODS.get(user_filters.get(uid, "multistage"))
    
    status_text = (
        "‚úÖ –ë–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω\n"
        "–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è: –ö–ª—é—á–∏ ‚Üí OpenRouter ‚Üí GPT\n"
        f"–ò—Å—Ç–æ—á–Ω–∏–∫–æ–≤: {len(NEWS_SOURCES)}\n"
        f"–ö—ç—à —Å—Å—ã–ª–æ–∫: {len(sent_links_cache)}\n"
        f"–¢–µ–∫—É—â–∏–π –º–µ—Ç–æ–¥: {method}"
    )
    await message.answer(status_text)

# –ó–∞–ø—É—Å–∫
async def main():
    await bot.delete_webhook()
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())