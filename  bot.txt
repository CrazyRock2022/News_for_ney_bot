import logging
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.types import ParseMode, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils import executor
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from aiogram.dispatcher.filters import CommandStart
import feedparser
import sqlite3
from datetime import datetime, timedelta
import openai
import os
from typing import Union

# Настройки логирования
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.DEBUG,  # Уровень логирования
    handlers=[
        logging.FileHandler("bot.log", mode='a'),
        logging.StreamHandler()
    ]
)

API_TOKEN = os.getenv("API_TOKEN")  # Токен вашего бота
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
openai.api_key = OPENAI_API_KEY

logging.info("Бот запущен, сессия началась.")

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)
scheduler = AsyncIOScheduler()
DB_FILE = "users.db"

# Инициализация базы данных
def init_db():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY)")
    cur.execute("CREATE TABLE IF NOT EXISTS sent_links (link TEXT PRIMARY KEY)")
    cur.execute("CREATE TABLE IF NOT EXISTS sources (url TEXT PRIMARY KEY)")
    # Добавляем источники новостей
    default_sources = [
        'https://forklog.com/feed/',
        'https://ru.cointelegraph.com/rss',
        'https://bits.media/rss/news/',
        'https://incrypted.com/feed/',
        'https://cryptopanic.com/news/rss/',
        'https://cointelegraph.com/rss',
        'https://decrypt.co/feed',
        'https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml',
        'https://www.cbr.ru/rss/',
        'http://www.finmarket.ru/rss/',
        'https://rssexport.rbc.ru/rbcnews/news/eco/index.rss',
        'https://www.kommersant.ru/RSS/news.xml',
        'https://www.forbes.ru/rss',
        'https://24.kg/rss/',
        'https://akipress.org/rss/news.rss',
        'https://www.themoscowtimes.com/rss',
        'https://blogs.imf.org/feed/',
        'https://www.bis.org/rss/home.xml',
    ]
    for url in default_sources:
        cur.execute("INSERT OR IGNORE INTO sources (url) VALUES (?)", (url,))
    conn.commit()
    conn.close()

# ---------- КОМАНДЫ ----------
@dp.message_handler(CommandStart())
async def start(message: types.Message):
    user_id = message.from_user.id
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO users (id) VALUES (?)", (user_id,))
    conn.commit()
    conn.close()

    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton("Справка", callback_data="help")
    )
    await message.answer("Привет! Я пришлю тебе свежие и релевантные новости по теме A7A5, крипты и цифрового рубля.", reply_markup=keyboard)

# ---------- СПРАВКА ----------
HELP_TEXT = (
    "Вот что я умею:\n\n"
    "/digest — получить свежие релевантные новости\n"
    "/addsource <url> — добавить сайт/RSS источник\n"
    "/removesource <url> — удалить источник\n"
    "/listsources — показать все источники\n"
    "/help — справка\n"
)

@dp.callback_query_handler(lambda c: c.data == "help")
async def help_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(HELP_TEXT)

@dp.message_handler(commands=["help"])
async def help_command(message: types.Message):
    await message.answer(HELP_TEXT)

@dp.message_handler(commands=["digest"])
async def send_digest(message: types.Message):
    articles = await get_news()  # Получаем новости

    # Статистика по каждому источнику
    sources_stats = {}
    for article in articles:
        source = article['source']
        if source not in sources_stats:
            sources_stats[source] = {'relevant': 0, 'possible': 0, 'irrelevant': 0, 'total': 0}

        if article['status'] == 'Relevant':
            sources_stats[source]['relevant'] += 1
        elif article['status'] == 'Irrelevant':
            sources_stats[source]['irrelevant'] += 1
        elif article['status'] == 'Possible':
            sources_stats[source]['possible'] += 1

        sources_stats[source]['total'] += 1

    # Отправляем статистику
    stats_message = "Результаты:\n\n"
    total_relevant = total_possible = total_irrelevant = 0

    for source, stats in sources_stats.items():
        stats_message += f"{source} — прочитано {stats['total']} новостей, из которых {stats['relevant']} релевантных, {stats['possible']} возможно релевантных, {stats['irrelevant']} нерелевантных\n"
        total_relevant += stats['relevant']
        total_possible += stats['possible']
        total_irrelevant += stats['irrelevant']

    stats_message += f"\nИтого: прочитано {total_relevant + total_possible + total_irrelevant} новостей, из которых {total_relevant} релевантных, {total_possible} возможно релевантных, {total_irrelevant} нерелевантных.\n"

    # Кнопка для получения новостей
    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton("Получить новости", callback_data="get_news")
    )

    await message.answer(stats_message, reply_markup=keyboard)

# ---------- Кнопка "Получить новости" ----------
@dp.callback_query_handler(lambda c: c.data == "get_news")
async def get_news_callback(callback: types.CallbackQuery):
    # Сначала отправляем релевантные новости
    articles = await get_news()
    relevant_articles = [article for article in articles if article['status'] == 'Relevant']
    
    if relevant_articles:
        for article in relevant_articles:
            await callback.message.answer(f"<b>{article['title']}</b>\n{article['link']}", parse_mode=ParseMode.HTML)

    # Если релевантных нет, уведомим пользователя
    if not relevant_articles:
        await callback.message.answer("Нет релевантных новостей.")

# ---------- GPT-ФИЛЬТР ----------

# Новый метод работы с OpenAI для запроса через промт
async def get_gpt_response(prompt):
    try:
        logging.info(f"Отправка запроса в GPT: {prompt}")
        response = await openai.ChatCompletion.acreate(
            model="gpt-4-turbo",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=150
        )
        logging.info(f"Ответ от GPT: {response.choices[0].message['content'].strip()}")
        return response.choices[0].message['content'].strip()
    except Exception as e:
        logging.error(f"Ошибка при запросе к OpenAI: {e}")
        return None

# ---------- ПАРСИНГ ----------
async def get_news():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT url FROM sources")
    sources = [r[0] for r in cur.fetchall()]
    new_articles = []

    for url in sources:
        feed = feedparser.parse(url)
        for entry in feed.entries:
            title = entry.title
            link = entry.link
            summary = entry.get("summary", "")
            published = entry.get("published_parsed")

            if published:
                pub_time = datetime(*published[:6])
                if datetime.utcnow() - pub_time > timedelta(hours=168):
                    continue

            cur.execute("SELECT 1 FROM sent_links WHERE link=?", (link,))
            if not cur.fetchone():
                tags = [t['term'] for t in entry.get('tags', [])] if 'tags' in entry else []
                category = entry.get('category')
                content = entry.get('content', [{}])[0].get('value') if 'content' in entry else None

                status = await is_relevant(title, summary, tags, category, content)
                if status:
                    new_articles.append({
                        'title': title,
                        'link': link,
                        'status': 'Relevant',
                        'source': url
                    })
                elif status is None:
                    new_articles.append({
                        'title': title,
                        'link': link,
                        'status': 'Possible',
                        'source': url
                    })
                else:
                    new_articles.append({
                        'title': title,
                        'link': link,
                        'status': 'Irrelevant',
                        'source': url
                    })

    conn.commit()
    conn.close()
    return new_articles

# ---------- Запланированная задача
async def scheduled_job():
    print("Scheduled job running!")
    # Здесь можно добавить другие задачи
    await get_news()  # Добавим получение новостей

# ---------- НАЧАЛО РАБОТЫ БОТА И СТАРТ ----------
async def on_startup(_):
    # Инициализация базы данных
    init_db()

    # Удаление старых вебхуков
    await bot.delete_webhook(drop_pending_updates=True)

    # Убираем вебхук
    await bot.set_webhook(url='')

    # Запуск планировщика
    scheduler.add_job(scheduled_job, "cron", hour=11, minute=0)
    scheduler.start()

# Здесь бот будет ждать обновлений
executor.start_polling(dp, skip_updates=True, on_startup=on_startup)