import asyncio
import logging
import os
import sqlite3
from datetime import datetime, timedelta
from typing import List, Dict, Optional

import feedparser
from aiohttp import ClientSession
from aiogram import Bot, Dispatcher, Router, F
from aiogram.enums import ParseMode
from aiogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import StatesGroup, State
from aiogram.utils.markdown import hbold
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from openai import OpenAI
from dotenv import load_dotenv

# Загрузка переменных окружения
load_dotenv()
API_TOKEN = os.getenv("API_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Настройка бота и диспетчера
client = OpenAI(api_key=OPENAI_API_KEY)
bot = Bot(token=API_TOKEN, default=ParseMode.HTML)
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)

scheduler = AsyncIOScheduler()
DB_FILE = "users.db"

# Хранилище пользовательских промтов
user_prompts: Dict[int, str] = {}

# ---------- БАЗА ДАННЫХ ----------
def init_db():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY)")
    cur.execute("CREATE TABLE IF NOT EXISTS sources (url TEXT PRIMARY KEY)")
    cur.execute("DELETE FROM sources")  # пересоздание источников
    sources = [
        "https://forklog.com/feed/",
        "https://ru.cointelegraph.com/rss",
        "https://bits.media/rss/news/",
        "https://incrypted.com/feed/",
        "https://cryptopanic.com/news/rss/",
        "https://cointelegraph.com/rss",
        "https://decrypt.co/feed",
        "https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml",
        "https://www.cbr.ru/rss/",
        "http://www.finmarket.ru/rss/",
        "https://rssexport.rbc.ru/rbcnews/news/eco/index.rss",
        "https://www.kommersant.ru/RSS/news.xml",
        "https://www.forbes.ru/rss",
        "https://24.kg/rss/",
        "https://akipress.org/rss/news.rss",
        "https://www.themoscowtimes.com/rss",
        "https://blogs.imf.org/feed/",
        "https://www.bis.org/rss/home.xml",
    ]
    for url in sources:
        cur.execute("INSERT OR IGNORE INTO sources (url) VALUES (?)", (url,))
    conn.commit()
    conn.close()
    
# ---------- GPT-ФИЛЬТР ----------
async def gpt_check(prompt: str) -> str:
    try:
        loop = asyncio.get_running_loop()
        response = await loop.run_in_executor(
            None,
            lambda: client.chat.completions.create(
                model="gpt-3.5-turbo",  # можно заменить на gpt-4
                messages=[{"role": "user", "content": prompt}],
                max_tokens=5,
                temperature=0
            )
        )
        return response.choices[0].message.content.strip().lower()
    except Exception as e:
        logger.error(f"OpenAI error: {e}", exc_info=True)
        return "нет"

# ---------- СОСТОЯНИЯ ДЛЯ ПРОМТА ----------
class PromptState(StatesGroup):
    waiting_for_prompt = State()

# ---------- КОМАНДЫ ----------
@router.message(F.text == "/start")
async def cmd_start(message: Message):
    user_id = message.from_user.id
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO users (id) VALUES (?)", (user_id,))
    conn.commit()
    conn.close()
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="Справка", callback_data="help")]]
    )
    await message.answer("Привет! Я пришлю тебе новости по теме A7A5, крипты и цифрового рубля.", reply_markup=keyboard)

@router.callback_query(F.data == "help")
async def callback_help(callback: CallbackQuery):
    await callback.message.edit_text(get_help_text())

@router.message(F.text == "/help")
async def cmd_help(message: Message):
    await message.answer(get_help_text())

def get_help_text():
    return (
        "Доступные команды:\n"
        "/digest — релевантные новости\n"
        "/addsource <url> — добавить источник\n"
        "/removesource <url> — удалить источник\n"
        "/listsources — показать источники\n"
        "/clearlinks — очистить сохранённые ссылки\n"
        "/prompt — задать свой промт\n"
        "/help — справка"
    )
    
# ---------- КОМАНДА PROMPT ----------
@router.message(F.text == "/prompt")
async def cmd_prompt(message: Message, state: FSMContext):
    await message.answer("Введите новый запрос для GPT (например: \"Все новости, связанные с криптовалютой, инфляцией или центральными банками\"):")
    await state.set_state(PromptState.waiting_for_prompt)

@router.message(PromptState.waiting_for_prompt)
async def save_prompt(message: Message, state: FSMContext):
    user_prompt[message.from_user.id] = message.text.strip()
    await message.answer("Новый запрос сохранён. Теперь выполните команду /digest.")
    await state.clear()

# ---------- КОМАНДА /digest ----------
@router.message(F.text == "/digest")
async def cmd_digest(message: Message):
    user_id = message.from_user.id
    prompt = user_prompt.get(user_id, DEFAULT_PROMPT)

    articles, stats = await get_news(prompt)
    total = stats["total"]
    relevant = stats["relevant"]
    possible = stats["possible"]
    irrelevant = stats["irrelevant"]

    text = (
        f"Результаты:\n"
        f"Всего новостей: {total}\n"
        f"Релевантных: {relevant}\n"
        f"Возможно релевантных: {possible}\n"
        f"Нерелевантных: {irrelevant}\n"
    )

    for source, stat in stats["sources"].items():
        text += f"\nИсточник: {source}\n"
        text += f"  Прочитано: {stat['total']}, Да: {stat['relevant']}, Нет: {stat['irrelevant']}, Возможно: {stat['possible']}\n"

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="Показать новости", callback_data="show_news")]]
    )

    await message.answer(text, reply_markup=keyboard)

# ---------- КНОПКА ПОКАЗАТЬ НОВОСТИ ----------
@router.callback_query(F.data == "show_news")
async def show_news(callback: CallbackQuery):
    user_id = callback.from_user.id
    prompt = user_prompt.get(user_id, DEFAULT_PROMPT)
    articles, _ = await get_news(prompt)

    count = 0
    for article in articles:
        if article["status"] == "relevant":
            await callback.message.answer(f"<b>{article['title']}</b>\n{article['link']}", parse_mode="HTML")
            count += 1

    if count == 0:
        await callback.message.answer("Нет релевантных новостей.")
        
# ---------- ПАРСИНГ НОВОСТЕЙ ----------
async def get_news(prompt: str):
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT url FROM sources")
    sources = [r[0] for r in cur.fetchall()]
    new_articles = []
    stats = {
        "total": 0,
        "relevant": 0,
        "possible": 0,
        "irrelevant": 0,
        "sources": {}
    }

    for url in sources:
        parsed = feedparser.parse(url)
        source_stats = {"relevant": 0, "possible": 0, "irrelevant": 0, "total": 0}

        for entry in parsed.entries:
            title = entry.get("title", "")
            link = entry.get("link", "")
            summary = entry.get("summary", "")
            content = entry.get("content", [{}])[0].get("value", "")
            full_text = f"{title}\n\n{summary}\n\n{content}"

            # Не проверяем дату, чтобы не отбрасывались новости без published_parsed

            cur.execute("SELECT 1 FROM sent_links WHERE link=?", (link,))
            if cur.fetchone():
                continue

            decision = await gpt_check(f"{prompt}\n\n---\n{full_text}")
            status = (
                "relevant" if "да" in decision
                else "possible" if "возможно" in decision or "может" in decision
                else "irrelevant"
            )

            new_articles.append({
                "title": title,
                "link": link,
                "status": status,
                "source": url
            })

            source_stats["total"] += 1
            source_stats[status] += 1
            stats[status] += 1
            stats["total"] += 1

            # Не сохраняем ссылку в БД, чтобы можно было получать обновления заново

        stats["sources"][url] = source_stats

    conn.close()
    return new_articles, stats

# ---------- GPT АНАЛИЗ ----------
async def gpt_check(prompt: str) -> str:
    try:
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=5,
                temperature=0
            )
        )
        answer = response.choices[0].message.content.strip().lower()
        return answer
    except Exception as e:
        logging.error(f"GPT ERROR: {e}", exc_info=True)
        return "нет"

# ---------- ИНИЦИАЛИЗАЦИЯ БД ----------
def init_db():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY)")
    cur.execute("CREATE TABLE IF NOT EXISTS sources (url TEXT PRIMARY KEY)")
    cur.execute("CREATE TABLE IF NOT EXISTS sent_links (link TEXT PRIMARY KEY)")
    conn.commit()

    # Источники по умолчанию
    default_sources = [
        'https://forklog.com/feed/',
        'https://ru.cointelegraph.com/rss',
        'https://bits.media/rss/news/',
        'https://incrypted.com/feed/',
        'https://cryptopanic.com/news/rss/',
        'https://cointelegraph.com/rss',
        'https://decrypt.co/feed',
        'https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml',
        'https://www.cbr.ru/rss/',
        'http://www.finmarket.ru/rss/',
        'https://rssexport.rbc.ru/rbcnews/news/eco/index.rss',
        'https://www.kommersant.ru/RSS/news.xml',
        'https://www.forbes.ru/rss',
        'https://24.kg/rss/',
        'https://akipress.org/rss/news.rss',
        'https://www.themoscowtimes.com/rss',
        'https://blogs.imf.org/feed/',
        'https://www.bis.org/rss/home.xml',
    ]
    for url in default_sources:
        cur.execute("INSERT OR IGNORE INTO sources (url) VALUES (?)", (url,))
    conn.commit()
    conn.close()

# ---------- ПЛАНОВАЯ ЗАДАЧА ----------
async def scheduled_job():
    prompt = DEFAULT_PROMPT
    articles, stats = await get_news(prompt)
    if articles:
        for article in articles:
            if article["status"] == "relevant":
                await bot.send_message(
                    ADMIN_ID,
                    f"<b>{article['title']}</b>\n{article['link']}",
                    parse_mode=ParseMode.HTML
                )

# ---------- СТАРТ БОТА ----------
async def on_startup(dispatcher):
    init_db()
    await bot.delete_webhook(drop_pending_updates=True)
    scheduler.add_job(scheduled_job, "cron", hour=11, minute=0)
    scheduler.start()
    logging.info("Бот запущен")

if __name__ == "__main__":
    logging.info("Запуск Telegram-бота...")
    try:
        import asyncio
        asyncio.run(dp.start_polling(bot, skip_updates=True, on_startup=on_startup))
    except (KeyboardInterrupt, SystemExit):
        logging.info("Бот остановлен")